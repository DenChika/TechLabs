# Лабораторная 4
## Point 1
### Задание
Есть материальная точка, находящаяся в (0,0). Её нужно за минимальное количество шагов дойти до точки (1,1).\
При этом есть n-ое количество кругов - препятствий, сталкиваясь с которыми точка прекращает своё движение. Параметры этих кругов мы задаём сами.
### Решение
#### Движение
Для начала разберём, как наша точка движется. У неё есть параметры: позиция, скорость и ускорение, которые, для удобства, задаются векторами.\
Общий план таков:\
К вектору скорости точки прибавляется вектор ускорения, а затем вектор скорости прибавляется к вектору позиции точки. Этим и определяется следующая через условное dt её позиция.\
Это и есть ген - действие ускорения в i-ый момент времени. А соответственно хромосома - набор таких ускорений, то есть весь путь точки до тех пор, пока она не окажется у цели, не врежется в края или препятствия, или не сделает слишком много шагов.

Теперь немного про реализацию:\
У каждой точки есть свой "мозг", в котором случайным образом задаётся какое-то k-ое количество направлений ускорений, которые будут приложены к точке по порядку, то есть определит её хромосому.\
В моей реализации "случайным образом" значит, что задаётся рандомный угол (0, 2$\pi$), и по этому углу определяется вектор ускорения, причём фиксированной длины.

![image](https://user-images.githubusercontent.com/79001610/169453727-32c8722d-4d08-4306-b4b8-cd0f6210e1e7.png)

Также у скорости есть предел. Если этот предел превышен, то координаты вектора берутся по модулю этого предела, тем самым мы не даём точке двигаться слишком быстро, что облегчает её путь обучения, потому что при большой скорости точке трудно попасть в цель.

#### Фитнесс функция
Зададим фитнесс функцию - проще говоря, величину награды точке за её путь. Соответственно чем оптимальнее путь, тем больше у точки фитнесс функция.\
Один из вариантов задать фитнесс функцию такой:
```cs
if (IsReached)
    Fitness = 50000.0 / (Brain.Step * Brain.Step);
else if (!IsSlow)
{
    double distX = Position.X - Goal.X;
    double distY = Position.Y - Goal.Y;
    double dist = Math.Sqrt(distX * distX + distY * distY);
    Fitness = 0.1 / (dist * dist);
}
else
{
    Fitness = 0.0;
}
```
Другими словами, если точка дошла до цели, то её награда будет гораздо больше, чем у точки, которая до цели не дошла (отсюда такая большая константа 50000).\
Причём если точка дошла до цели, то её фитнесс функция будет зависеть от количества шагов, за которые она сделала до того как придти к цели: чем меньше шагов, тем больше фитнесс функция.\
А если точка не дошла, а врезалась в край/препятствие, то её фитнесс функция будет зависить от расстояния до цели.\
А если же точка сделала слишком много шагов, то её фитнесс функция будет равна 0 (это введено из-за того, что появилась проблема с тем, когда точка дошла до лимита шагов прям около цели и её фитнесс функция могла стать даже больше, чем у точки, которая дошла до цели, соответственно следующие поколения учились бы неправильно).

#### Поколение
Теперь определим, как точки, грубо говоря, наследуются друг от друга. После того, как все точки этого поколения остановились, для каждой новой точки следующего поколения определяется родитель, чей путь она повторит (чей "мозг" она скопирует).\
Родитель точки определяется следующим образом:\
В конце каждого поколения значения фитнесс функций всех точек суммируются, и затем выбирается случайное число от 0 до значения этой суммы. И соответственно на фитнесс функцию какой точки это число попадёт, та точка и будет родителем данной.

![image](https://user-images.githubusercontent.com/79001610/169456727-19b9b47b-aa5c-4779-9be8-a24262013983.png)

Нетрудно заметить, что чем больше у какой-то определённой точки фитнесс функция, тем больше у неё вероятность стать родителем для любой точки следующего поколения.

#### Улучшение обучения
Вроде как всё хорошо, однако возникает проблема:\
Допустим, у нас есть всего одна точка, которая дошла до цели, но сделала это максимально неэффективно. Тогда это приведёт к тому, что эта точка станет родителем для всё большего и большего количества точек следующих поколений.\
И в итоге наши особи выучатся неправильно, так как задача стоит дойти до цели максимально оптимально.

Для этого у нас будет существовать вероятность мутации генов. Другими словами, у каждого гена хромосомы будет фиксированная вероятность мутировать, то есть поменять направление ускорения. Так, при плохом кейсе, описанном выше, будет существовать вероятность того, что у какой-то точки смутирует один или несколько генов, и она в итоге дойдёт до цели более оптимально.\
Именно мутация генов является ключом к оптимальности решения.

## Point 2
### Метрики
Соберём метрики и посмотрим, сколько памяти выделяется во время прогонки алгоритма на 1000 точках:

![image](https://user-images.githubusercontent.com/79001610/169488772-050087d0-cb1a-4b9c-895e-763832641ffa.png)

![image](https://user-images.githubusercontent.com/79001610/169488558-9acadd28-ce3b-467e-9c96-5a9cd645e3d8.png)

![image](https://user-images.githubusercontent.com/79001610/169495389-4cb9cd4f-8eef-41bf-ba37-a2a962e8c5f0.png)

### Предполагаемые проблемы
Если посмотреть внутрь метрик, то можно заметить, что основная проблема с памятью появляется в этом фрагменте кода:
```cs
public Brain(int size)
{
    Directions = new Vector2[size];
    Step = 0;
    MutateChance = 0.025;
    Randomize();
}
```
То есть больше всего памяти выделяется при создании массива векторов в "мозге" каждой точке.
## Point 3
### Решение проблем
Одним из решений проблем является не генерировать каждый раз массив и выделять память под него, а перезаполнять старые массивы. То есть условно "мозг", генерируя набор ускорений, перезаполняется. Для этого можно использовать ArrayPool: в конструкторе "мозга" доставать массив из пула, а в конце нового поколения - возвращать в пул "мозг" каждлй точки. Возвращаясь к фрагменту кода выше, мы можем переписать его вот так:
```cs
public Brain(int size)
{
    Directions = ArrayPool<Vector2>.Shared.Rent(size);
    Step = 0;
    MutateChance = 0.025;
    Randomize();
}
```
### Новые метрики

![image](https://user-images.githubusercontent.com/79001610/169626224-b39b9c78-f90b-42ea-aa2a-924c4a9fecf1.png)

![image](https://user-images.githubusercontent.com/79001610/169626218-87285e9e-0542-4608-9c94-130688a760a5.png)
